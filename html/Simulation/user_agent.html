<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>Simulation.user_agent API documentation</title>
<meta name="description" content="Module with UserAgent class implementation." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Simulation.user_agent</code></h1>
</header>
<section id="section-intro">
<p>Module with UserAgent class implementation.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Module with UserAgent class implementation.

&#34;&#34;&#34;

import numpy as np
from mesa import Agent, Model
from Simulation.information import Information

from Simulation.integration_function import check_integration


class UserAgent(Agent):
    &#34;&#34;&#34;UserAgent is a class representing user of some social website in our simulation.

    UserAgent has internal class called Memory that represents user memory.
    &#34;&#34;&#34;

    def __init__(
        self,
        unique_id: int,
        model: Model,
        memory_capacity: int,
        user_latitude: float,
        user_sharpness: float,
    ):
        &#34;&#34;&#34;
        Creates new UserAgent with given parameters.

        Args:
            unique_id (int): unique id of our user
            model (Model): model of simulation in which our UserAgent participate
            memory_capacity (int): Maximal number of informations that user can have in it&#39;s memory
            user_latitude (float): Latitude of acceptance of our UserAgent
            user_sharpness (float): Sharpness of acceptance of our UserAgent
        &#34;&#34;&#34;
        super().__init__(unique_id, model)
        self.latitude = user_latitude
        self.sharpness = user_sharpness
        self.info_count = 0

        self.memory = self.Memory(Information(), memory_capacity)
        self.position = self.memory.calculate_user_position()
        self.mean_info_dist = self.memory.calculate_mean_distance(self.position)

    class Memory:
        &#34;&#34;&#34;
        Internal class representing user memory and providing methods to modify and read it
        &#34;&#34;&#34;

        def __init__(self, first_info_bit: Information, mem_capacity: int):
            &#34;&#34;&#34;Creates new Memory with one Information and given capacity

            Args:
                first_info_bit (Information): Information that will be stored in info_bits
                mem_capacity (int): Capacity of Memory, how many Information it will be able to store
            &#34;&#34;&#34;
            self.mem_capacity = mem_capacity
            self.info_bits = np.zeros(shape=(mem_capacity, 3))
            self.size = 0
            self.add_new_info_bit(first_info_bit)

        def add_new_info_bit(self, info_bit: Information):
            &#34;&#34;&#34;Saves new Information user memory, if memory is full
            it replace one random info_bit from memory with the new one.
            Information is stored as row in matrix. In first column id&#39;s of Informations are stored and
            every other column represents Informations positions in specific dimension

            Args:
                info_bit (Information): Information to save
            &#34;&#34;&#34;
            # removing random info_bit if memory is full
            if self.size &gt;= self.mem_capacity:
                info_bit_to_remove = np.random.randint(self.mem_capacity)
                self.info_bits[info_bit_to_remove] = info_bit.to_numpy()
            # appending memory with new info otherwise
            else:
                self.info_bits[self.size] = info_bit.to_numpy()
                self.size += 1

        def calculate_user_position(self) -&gt; np.ndarray:
            &#34;&#34;&#34;Calculates user position based on positions of info_bits in user memory

            Returns:
                np.ndarray: new user position, mean of all informations in memory
            &#34;&#34;&#34;
            return np.mean(self.info_bits[: self.size, 1:3], axis=0)

        def get_random_information(self) -&gt; Information:
            &#34;&#34;&#34;Creates Information based on random row from info_bits attribute

            Returns:
                Information: New Information based on existing one
            &#34;&#34;&#34;
            if self.size == 0:
                return None
            return Information(
                self.info_bits[np.random.randint(self.size), :].reshape((1, 3))
            )

        def get_info_bits_ids(self) -&gt; np.ndarray:
            &#34;&#34;&#34;Returns id&#39;s of all Informations in info_bits

            Returns:
                np.ndarray: Array of all Information id&#39;s in info_bits
            &#34;&#34;&#34;
            return self.info_bits[: self.size, 0]

        def calculate_mean_distance(self, position: np.ndarray) -&gt; float:
            &#34;&#34;&#34;
            Calculates mean distance from position passed as parameter and Informations in UserAgent Memory

            Args:
                position (np.ndarray): Position from which mean distance should be calculated

            Returns:
                float: Mean distance
            &#34;&#34;&#34;
            distances = np.linalg.norm(
                self.info_bits[: self.size, 1:3] - position, axis=1
            )
            return np.mean(distances)

    def get_random_information(self) -&gt; Information:
        &#34;&#34;&#34;Creates new Information based on random Information from UserAgent Memory

        Returns:
            Information: New Information based on existing one

        &#34;&#34;&#34;
        return self.memory.get_random_information()

    def update_position(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Updates position with new position calculated by UserAgent Memory
            Also updates mean_info_dist attribute, value of mean distance between user and Informations in his memory

        Returns:
            np.ndarray: [description]
        &#34;&#34;&#34;
        self.position = self.memory.calculate_user_position()
        self.mean_info_dist = self.memory.calculate_mean_distance(self.position)
        return self.position

    def try_to_integrate_info_bit(self, info_bit: Information) -&gt; bool:
        &#34;&#34;&#34;Tries to integrate new Information to UserAgent Memory memory based on attitude
        distance between UserAgent and Information, UserAgent latitude and sharpness.

        If id of Information is already present in UserAgent Memory, method
        returns False before trying to integrate these Information.

        Args:
            info_bit (Information): Information that UserAgent tries to integrate

        Returns:
            bool: indicator if integration was succesfull
        &#34;&#34;&#34;

        # if user already knows this info
        if info_bit.get_id() in self.memory.get_info_bits_ids():
            return False
        if check_integration(
            self.position,
            info_bit.position,
            self.latitude,
            self.sharpness,
        ):
            self.memory.add_new_info_bit(info_bit)
            return True
        else:
            return False</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Simulation.user_agent.UserAgent"><code class="flex name class">
<span>class <span class="ident">UserAgent</span></span>
<span>(</span><span>unique_id: int, model: mesa.model.Model, memory_capacity: int, user_latitude: float, user_sharpness: float)</span>
</code></dt>
<dd>
<div class="desc"><p>UserAgent is a class representing user of some social website in our simulation.</p>
<p>UserAgent has internal class called Memory that represents user memory.</p>
<p>Creates new UserAgent with given parameters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>unique_id</code></strong> :&ensp;<code>int</code></dt>
<dd>unique id of our user</dd>
<dt><strong><code>model</code></strong> :&ensp;<code>Model</code></dt>
<dd>model of simulation in which our UserAgent participate</dd>
<dt><strong><code>memory_capacity</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximal number of informations that user can have in it's memory</dd>
<dt><strong><code>user_latitude</code></strong> :&ensp;<code>float</code></dt>
<dd>Latitude of acceptance of our UserAgent</dd>
<dt><strong><code>user_sharpness</code></strong> :&ensp;<code>float</code></dt>
<dd>Sharpness of acceptance of our UserAgent</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UserAgent(Agent):
    &#34;&#34;&#34;UserAgent is a class representing user of some social website in our simulation.

    UserAgent has internal class called Memory that represents user memory.
    &#34;&#34;&#34;

    def __init__(
        self,
        unique_id: int,
        model: Model,
        memory_capacity: int,
        user_latitude: float,
        user_sharpness: float,
    ):
        &#34;&#34;&#34;
        Creates new UserAgent with given parameters.

        Args:
            unique_id (int): unique id of our user
            model (Model): model of simulation in which our UserAgent participate
            memory_capacity (int): Maximal number of informations that user can have in it&#39;s memory
            user_latitude (float): Latitude of acceptance of our UserAgent
            user_sharpness (float): Sharpness of acceptance of our UserAgent
        &#34;&#34;&#34;
        super().__init__(unique_id, model)
        self.latitude = user_latitude
        self.sharpness = user_sharpness
        self.info_count = 0

        self.memory = self.Memory(Information(), memory_capacity)
        self.position = self.memory.calculate_user_position()
        self.mean_info_dist = self.memory.calculate_mean_distance(self.position)

    class Memory:
        &#34;&#34;&#34;
        Internal class representing user memory and providing methods to modify and read it
        &#34;&#34;&#34;

        def __init__(self, first_info_bit: Information, mem_capacity: int):
            &#34;&#34;&#34;Creates new Memory with one Information and given capacity

            Args:
                first_info_bit (Information): Information that will be stored in info_bits
                mem_capacity (int): Capacity of Memory, how many Information it will be able to store
            &#34;&#34;&#34;
            self.mem_capacity = mem_capacity
            self.info_bits = np.zeros(shape=(mem_capacity, 3))
            self.size = 0
            self.add_new_info_bit(first_info_bit)

        def add_new_info_bit(self, info_bit: Information):
            &#34;&#34;&#34;Saves new Information user memory, if memory is full
            it replace one random info_bit from memory with the new one.
            Information is stored as row in matrix. In first column id&#39;s of Informations are stored and
            every other column represents Informations positions in specific dimension

            Args:
                info_bit (Information): Information to save
            &#34;&#34;&#34;
            # removing random info_bit if memory is full
            if self.size &gt;= self.mem_capacity:
                info_bit_to_remove = np.random.randint(self.mem_capacity)
                self.info_bits[info_bit_to_remove] = info_bit.to_numpy()
            # appending memory with new info otherwise
            else:
                self.info_bits[self.size] = info_bit.to_numpy()
                self.size += 1

        def calculate_user_position(self) -&gt; np.ndarray:
            &#34;&#34;&#34;Calculates user position based on positions of info_bits in user memory

            Returns:
                np.ndarray: new user position, mean of all informations in memory
            &#34;&#34;&#34;
            return np.mean(self.info_bits[: self.size, 1:3], axis=0)

        def get_random_information(self) -&gt; Information:
            &#34;&#34;&#34;Creates Information based on random row from info_bits attribute

            Returns:
                Information: New Information based on existing one
            &#34;&#34;&#34;
            if self.size == 0:
                return None
            return Information(
                self.info_bits[np.random.randint(self.size), :].reshape((1, 3))
            )

        def get_info_bits_ids(self) -&gt; np.ndarray:
            &#34;&#34;&#34;Returns id&#39;s of all Informations in info_bits

            Returns:
                np.ndarray: Array of all Information id&#39;s in info_bits
            &#34;&#34;&#34;
            return self.info_bits[: self.size, 0]

        def calculate_mean_distance(self, position: np.ndarray) -&gt; float:
            &#34;&#34;&#34;
            Calculates mean distance from position passed as parameter and Informations in UserAgent Memory

            Args:
                position (np.ndarray): Position from which mean distance should be calculated

            Returns:
                float: Mean distance
            &#34;&#34;&#34;
            distances = np.linalg.norm(
                self.info_bits[: self.size, 1:3] - position, axis=1
            )
            return np.mean(distances)

    def get_random_information(self) -&gt; Information:
        &#34;&#34;&#34;Creates new Information based on random Information from UserAgent Memory

        Returns:
            Information: New Information based on existing one

        &#34;&#34;&#34;
        return self.memory.get_random_information()

    def update_position(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Updates position with new position calculated by UserAgent Memory
            Also updates mean_info_dist attribute, value of mean distance between user and Informations in his memory

        Returns:
            np.ndarray: [description]
        &#34;&#34;&#34;
        self.position = self.memory.calculate_user_position()
        self.mean_info_dist = self.memory.calculate_mean_distance(self.position)
        return self.position

    def try_to_integrate_info_bit(self, info_bit: Information) -&gt; bool:
        &#34;&#34;&#34;Tries to integrate new Information to UserAgent Memory memory based on attitude
        distance between UserAgent and Information, UserAgent latitude and sharpness.

        If id of Information is already present in UserAgent Memory, method
        returns False before trying to integrate these Information.

        Args:
            info_bit (Information): Information that UserAgent tries to integrate

        Returns:
            bool: indicator if integration was succesfull
        &#34;&#34;&#34;

        # if user already knows this info
        if info_bit.get_id() in self.memory.get_info_bits_ids():
            return False
        if check_integration(
            self.position,
            info_bit.position,
            self.latitude,
            self.sharpness,
        ):
            self.memory.add_new_info_bit(info_bit)
            return True
        else:
            return False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>mesa.agent.Agent</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="Simulation.user_agent.UserAgent.Memory"><code class="name">var <span class="ident">Memory</span></code></dt>
<dd>
<div class="desc"><p>Internal class representing user memory and providing methods to modify and read it</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Simulation.user_agent.UserAgent.get_random_information"><code class="name flex">
<span>def <span class="ident">get_random_information</span></span>(<span>self) ‑> <a title="Simulation.information.Information" href="information.html#Simulation.information.Information">Information</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates new Information based on random Information from UserAgent Memory</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Information</code></dt>
<dd>New Information based on existing one</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_random_information(self) -&gt; Information:
    &#34;&#34;&#34;Creates new Information based on random Information from UserAgent Memory

    Returns:
        Information: New Information based on existing one

    &#34;&#34;&#34;
    return self.memory.get_random_information()</code></pre>
</details>
</dd>
<dt id="Simulation.user_agent.UserAgent.try_to_integrate_info_bit"><code class="name flex">
<span>def <span class="ident">try_to_integrate_info_bit</span></span>(<span>self, info_bit: <a title="Simulation.information.Information" href="information.html#Simulation.information.Information">Information</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Tries to integrate new Information to UserAgent Memory memory based on attitude
distance between UserAgent and Information, UserAgent latitude and sharpness.</p>
<p>If id of Information is already present in UserAgent Memory, method
returns False before trying to integrate these Information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>info_bit</code></strong> :&ensp;<code>Information</code></dt>
<dd>Information that UserAgent tries to integrate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>indicator if integration was succesfull</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def try_to_integrate_info_bit(self, info_bit: Information) -&gt; bool:
    &#34;&#34;&#34;Tries to integrate new Information to UserAgent Memory memory based on attitude
    distance between UserAgent and Information, UserAgent latitude and sharpness.

    If id of Information is already present in UserAgent Memory, method
    returns False before trying to integrate these Information.

    Args:
        info_bit (Information): Information that UserAgent tries to integrate

    Returns:
        bool: indicator if integration was succesfull
    &#34;&#34;&#34;

    # if user already knows this info
    if info_bit.get_id() in self.memory.get_info_bits_ids():
        return False
    if check_integration(
        self.position,
        info_bit.position,
        self.latitude,
        self.sharpness,
    ):
        self.memory.add_new_info_bit(info_bit)
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="Simulation.user_agent.UserAgent.update_position"><code class="name flex">
<span>def <span class="ident">update_position</span></span>(<span>self) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Updates position with new position calculated by UserAgent Memory
Also updates mean_info_dist attribute, value of mean distance between user and Informations in his memory</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_position(self) -&gt; np.ndarray:
    &#34;&#34;&#34;Updates position with new position calculated by UserAgent Memory
        Also updates mean_info_dist attribute, value of mean distance between user and Informations in his memory

    Returns:
        np.ndarray: [description]
    &#34;&#34;&#34;
    self.position = self.memory.calculate_user_position()
    self.mean_info_dist = self.memory.calculate_mean_distance(self.position)
    return self.position</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="Simulation" href="index.html">Simulation</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Simulation.user_agent.UserAgent" href="#Simulation.user_agent.UserAgent">UserAgent</a></code></h4>
<ul class="">
<li><code><a title="Simulation.user_agent.UserAgent.Memory" href="#Simulation.user_agent.UserAgent.Memory">Memory</a></code></li>
<li><code><a title="Simulation.user_agent.UserAgent.get_random_information" href="#Simulation.user_agent.UserAgent.get_random_information">get_random_information</a></code></li>
<li><code><a title="Simulation.user_agent.UserAgent.try_to_integrate_info_bit" href="#Simulation.user_agent.UserAgent.try_to_integrate_info_bit">try_to_integrate_info_bit</a></code></li>
<li><code><a title="Simulation.user_agent.UserAgent.update_position" href="#Simulation.user_agent.UserAgent.update_position">update_position</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>